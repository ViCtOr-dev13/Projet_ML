import pandas as pd 
import numpy as np

#scikit-learn KNN
from sklearn.neighbors import KNeighborsClassifier
#sckit learn random forest
from sklearn.ensemble import RandomForestClassifier
#sckit learn decision tree
from sklearn.tree import DecisionTreeClassifier

from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report
from from_url_to_csv import *
from DataProcessing import *
df_malware = pd.read_csv('C:/Users/victo/OneDrive/Documents/CybersecurityProject/FinalDataset/Malware.csv')
df_malware["URL_Type_obf_Type"] = df_malware["URL_Type_obf_Type"].replace(['benign'], 1).replace(['malware'], 0)
#change NaN value by O
#df_malware.fillna(0, inplace=True)
#compter le nombre de ligne contenant NaN
df_malware=df_malware.drop('NumberRate_Extension', axis=1)

df_malware.dropna(inplace = True)

# X and y
X = df_malware.drop('URL_Type_obf_Type', axis=1)
X = filterDataset(X, liste)
y = df_malware['URL_Type_obf_Type']
#train
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1)
#fit
#RF
rf = RandomForestClassifier(n_estimators=200, min_samples_split=5, min_samples_leaf=4, max_features='auto', max_depth=80, bootstrap=True)
rf.fit(X_train, y_train)


def overfitting_test(rf, X_train, X_test, y_train, y_test):
    """
    Fonction pour tester la présence de sur-ajustement (overfitting) d'un modèle.
    
    Args:
    rf : modèle de machine learning entraîné
    X_train : données d'entraînement (caractéristiques)
    X_test : données de test (caractéristiques)
    y_train : labels d'entraînement
    y_test : labels de test
    
    Returns:
    None (affiche les performances sur les ensembles d'entraînement et de test)
    """
    
    # Performance sur les ensembles d'entraînement
    train_accuracy = rf.score(X_train, y_train)
    train_predictions = rf.predict(X_train)
    train_precision = precision_score(y_train, train_predictions)
    train_recall = recall_score(y_train, train_predictions)
    train_f1 = f1_score(y_train, train_predictions)
    
    print("Performances sur l'ensemble d'entraînement :")
    print("Accuracy :", train_accuracy)
    print("Precision :", train_precision)
    print("Recall :", train_recall)
    print("F1-Score :", train_f1)
    
    # Performance sur les ensembles de test
    test_accuracy = rf.score(X_test, y_test)
    test_predictions = rf.predict(X_test)
    test_precision = precision_score(y_test, test_predictions)
    test_recall = recall_score(y_test, test_predictions)
    test_f1 = f1_score(y_test, test_predictions)
    
    print("/nPerformances sur l'ensemble de test :")
    print("Accuracy :", test_accuracy)
    print("Precision :", test_precision)
    print("Recall :", test_recall)
    print("F1-Score :", test_f1)

overfitting_test(rf, X_train, X_test, y_train, y_test)

url="http://2gis.ru/moscow/search/%D0%9F%D0%BE%D0%B5%D1%81%D1%82%D1%8C/tab/firms/zoom/11"
data = parse_url(url)
df_test = pd.DataFrame([data], columns=['Querylength', 'domain_token_count', 'path_token_count',
           'avgdomaintokenlen', 'longdomaintokenlen', 'avgpathtokenlen', 'tld',
           'charcompvowels', 'charcompace', 'ldl_url', 'ldl_domain', 'ldl_path',
           'ldl_filename', 'ldl_getArg', 'dld_url', 'dld_domain', 'dld_path',
           'dld_filename', 'dld_getArg', 'urlLen', 'domainlength', 'pathLength',
           'subDirLen', 'fileNameLen', 'this.fileExtLen', 'ArgLen', 'pathurlRatio',
           'ArgUrlRatio', 'argDomanRatio', 'domainUrlRatio', 'pathDomainRatio',
           'argPathRatio', 'executable', 'isPortEighty', 'NumberofDotsinURL',
           'ISIpAddressInDomainName', 'CharacterContinuityRate',
           'LongestVariableValue', 'URL_DigitCount', 'host_DigitCount',
           'Directory_DigitCount', 'File_name_DigitCount', 'Extension_DigitCount',
           'Query_DigitCount', 'URL_Letter_Count', 'host_letter_count',
           'Directory_LetterCount', 'Filename_LetterCount',
           'Extension_LetterCount', 'Query_LetterCount', 'LongestPathTokenLength',
           'Domain_LongestWordLength', 'Path_LongestWordLength',
           'sub-Directory_LongestWordLength', 'Arguments_LongestWordLength',
           'URL_sensitiveWord', 'URLQueries_variable', 'spcharUrl',
           'delimeter_Domain', 'delimeter_path', 'delimeter_Count',
           'NumberRate_URL', 'NumberRate_Domain', 'NumberRate_DirectoryName',
           'NumberRate_FileName', 'NumberRate_Extension', 'NumberRate_AfterPath',
           'SymbolCount_URL', 'SymbolCount_Domain', 'SymbolCount_Directoryname',
           'SymbolCount_FileName', 'SymbolCount_Extension',
           'SymbolCount_Afterpath', 'Entropy_URL', 'Entropy_Domain',
           'Entropy_DirectoryName', 'Entropy_Filename', 'Entropy_Extension',
           'Entropy_Afterpath'])
df_test=df_test.drop('NumberRate_Extension', axis=1)

#change tld to zero
df_test['tld']=0

X_test_test=df_test
y_test_test = rf.predict(X_test_test)
print(y_test_test)